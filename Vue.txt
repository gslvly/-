
基本结构：

script标签中：

Vue.directive('red', {			//或者第二个参数直接写function
	inserted(el，color) {//当元素挂载后执行。el为使用了v-red的标签。color是返回的一个对象，就是v-red='"green"'对象， 可用color.value取到设置值。
		el.style.color='red'
	}
})


    directives: {
      focus：{
	inserted(el, val) {
        	if(val.value) el.focus()
      	},
      	update(el, val){
        	if(val.value) el.focus()
      	}
      }，
      save(el, val) {
	typeof val //OBject
      }
    }
	






new Vue({
	el:'#box',			//获取元素
	data:{				//返回数据
		msg:'welcome vue'
	},
	methods:{			//返回方法
		show：function(){	//方法中无法return数据的。
			alert（'1'）
		}，
		add：function(){
			this.msg+='gs'
		}，
		do：_.debounce(fn,500)	//此函数将延迟0.5秒执行
	}，
	computed：{				//计算属性。a不能为data里的变量。
		a：{					//也可以直接使用a（）{return this.msg+1}
			get:fn,			//取值的时候触发，比如哪儿有console.log（a），就会触发。取值与设置值这儿没有必然的联系。但get必须返回一个值，不然a就是空值。取值也不是取得设置的值，是取的get返回的值。
			set：function（aa）{	
				this.b=1+aa	//给a设置值的时候调用此方法，比如哪儿有a=5，他就会触发。
			}			
		}
	}，
	aa:'abc'，				//自定义属性，用vm.$options.aa调用。
						
	conponents:{				//局部组件 此处的ddd在cononents标签中无法访问，只能通过全局data传递此信息。
		'ddd':{	
			template:'<h2>真标签</h2><bbb></bbb>'，		//挂载到ddd。值也可放选择器（‘#id’）,将模板全部卸载script标签中。不常用。一般都写在template标签中。
			data(){
				return{name:'gs'}			返回对象。
			}，
			conponents:{
				bbb：{					//继续套用子组件，需要放在父级的模板中才能使用。
					template："<a>子组件</a>"，
				}
			}
		}			
	},
	watch:{								//watch的使用与computed简写方式是一样的。						
		msg(a,b){						//a是新值，b是旧值。
			this.msg1=this.msg+'vvv'
		},
		msg:{
handler(){
alert(1)},
 deep:true
  },
  }
	},
	
})

html中
	<div id='box'>{{msg}}
		<components :is='a'></components>		//动态组件，此处会显示组件的内容，a为根组件的data，当a=ddd时，就会显示上面的h2真标签模板。也可以直接填ddd
	</div>  	


常用指令
	v-model='msg'			双向数据绑定。
 	v-once				添加属性，它的文本节点的{{a}}不会变。他会将渲染结果储存起来。

	v-for='(a,b) in arr'：		循环，将每次循环得内容放在文本节点中。会创建多个标签。	a是内容，b是index
	
	v-on:click='show(1)，abc="all"'	事件绑定，注意写法，all需要用引号，用逗号隔开2个执行的代码。需要借助methods中写function(){}
	v-on:dblclick=add		双击后调用add函数，
	v-show='true'			a=4时此标签显示
	{{msg}}				数据更新会跟着更新
	{{'aaa'}}			直接输出aaa
过滤器：跟directive 差不多
	Vue.filter（‘db’，function（value，msg）{ value 是默认传的，msg是自己传的。
		return n+1			//必须返回 默认是red   
	}）
		
	Vue.filter('aaa',{			//都需要return ，第二个参数为对象，一个一参数是过滤器名字。
		read(input){			//此处是model→view
			return input+'aa'
		},
		write(val){			//此处是View→model的数据。
			return val
		}
	})



事件：
	@click='a($event，b)'			点击调用a函数，其中$event会传送事件,也可以传递参数。
	@keydown.down.provent			按下键，并且会阻止默认行为。
	e.cancelBubble=true:			阻止冒泡。
	@click.stop:				阻止冒泡。
	e.preventDefult:			阻止默认行为
	@click.stop.prevent="doThat"		阻止冒泡和默认
	@contextmenu.prevent			右键点击取消默认行为。上同
	@click.once:				只能点击一次。
	e.keyCode				键码
	@click.13='fn()'			点击回车键就触发
	@click.enter='fn()'			上同
	@click.self="doThat"			只当事件在该元素本身（而不是子元素）触发时触发回调 
	@click.up|down|left|right
	click="fn1(),fn2()"			写全可以同时绑定多个函数。
	
自定义键盘信息：
	Vue.config.keyCodes.a=65		
	组件添加事件
		<aaa @click.native='fn'></aaa>	在组件根元素添加事件，必须用.native，因为组件根元素只能添加$emit('evt')发射的事件。要添加必须修饰，fn为根组件的的methods。			


事件修饰符：
	@keyup.alt.67="clear"	

属性：
	v-bind：src='url'			v-bind绑定属性
	：src='url'				简写绑定
	：class='[red，green]'			其中red为数据，在数据中写red：'red'，green：'green',在css中写的red是.red{color：red;};.green{background:green;}数据中会获取css中的属性。
	:class="[num==n?red1:'']"		
	:class="{red:true，blue：true}"		这儿的red为css中的red，后面的条件为true时有效。	
	:class="json"				将数据写在data中，调用json实现。并且可以在computed中计算哪些为真。
	:class='[isTrue?red:green]'		当isTrue为真时，切换为red。这儿都是data里面的属性。
	:style="{color:'red',backgroundColor:'gray'}"
	v-cloak:				防止闪烁，在css中写[v-cloak]{display：none}
	v-text：'msg'				在标签属性中写，可以预防闪烁。
	v-html:'<span>msg</span>'		上同，带转译。
	:key="item.id				它也可以用于强制替换元素/组件而不是重复使用它。用于完整地触发组件的生命周期钩子、触发过渡
	ref 					引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素; 如果用在子组件上，引用就指向组件实例:

实例方法：
	vm.$el:					就是元素。
	vm.$data:				数据对象。
	vm.$mount('#box)			手动挂载元素。常用，一般连缀
	vm.$options.aa				能够读到自定义的属性aa。设置自定义属性就是直接写aa：‘111’
	vm.$destroy（）				销毁对象。
	vm.$log()				查看现在数据的状态。
	vm.$watch('a',fn，{deep：true})		数据监听,当a发生变化执行fn，第三个参数没有的话，无法监听a的属性变化。
	this.$refs.t1				表示t1 dom元素，在元素中写上<div ref=‘t1’></div>可获取元素。当在aaa标签中，代表aaa组件。当在for循环中，代表循环所有标签的数组。
	this.$root				内部局部组件寻找根组件。此代表根组件。
	this.nextTick(callback)			更改数据后，dom立即更新，
表单绑定：v-model='msg'
	type:
		text:			value
		checkbox:		value :分为单个和多个，单个：true or false；多个必须绑定到数组，msg:[],msg最终为各个checkbox 的value拼接。
		radio：			value：多个单选框必须设置相同的name 而且都绑定相同的msg，都写v-model='msg'	
		textarea：		innerhtml：
		slecte标签		option的 value或者innerhtml。
	修饰符：v-model.lazy
		.lazy：			change事件触发，就是失去焦点，不添加是keyup事件。
		.number：		接收到数字类型。第一位为str，则变为str，第一位位num 则变为parsInt（num）
		.trim			自动去掉前后空格。
			
	事件：@input			vue自带事件。	


动画：						主要为重新渲染，设置key，show，if渲染。当:key变化时，就会重新渲染。
	过度：
	//标签中写
	<transition name=a><p>嗯</p></transition> 定义动画为a，写在标签中。
	//或者：
	<transition name=a
		enter-active-class="animated tada"		//直接在标签的属性节点填写.
    		leave-active-class="animated bounceOutRight"
	>
	//css中写		
	.a-transition{				
		transition：1s all;
	}
	.a-enter{opacity:0}			动画从什么属性开始。
	.a-enter-to{opacity:1}			动画结束时样式。
	.a-leave{opacity:1}			动画离开时样式
	.a-leave-to{opacity:0}			动画离开，结束后的样式。	
	transition 钩子				写在scrpt中。	
	<transition
  	v-on:before-enter="beforeEnter"
  	v-on:enter="enter"
  	v-on:after-enter="afterEnter"
 	 v-on:enter-cancelled="enterCancelled"
 	 v-on:before-leave="beforeLeave"
	  v-on:leave="leave"
 	 v-on:after-leave="afterLeave"
 	 v-on:leave-cancelled="leaveCancelled"
	>
	多元素过度：			指多个元素按条件显示出一个元素，并不是全部显示出来一起动画。
		<p :key='msg' ></p> 	重点在于:key ='msg',只要msg的值变了，因为key的唯一性，会让vue重新渲染dom。只要设置点击，让msg变化，就行了。
		mode=out-in ：		在transition中设置，出去的动画先进行，也可以进来的动画先进行。连续点击会出问题。 
	多组件过度：
		<component :is='view' class='t1'></component>	设置条件切换view内容就行了。
	列表过度：			指很多元素一起动画，for循环出来的。
		 <transition-group tag='p' name='t1'>		//必须用-group 。此会替换为tag设置的标签，不设置为span。
     			 <span v-for='a of msg' :key='a' class='t2'>{{a}}</span> //这儿只需要改变的那一个元素动画，所以要:key='a'，当a变化那一个元素，就是动画元素。
    		</transition-group>			

组件：
	全局组件
	方式一

	Vue.component('app-h',{
		template:'<h2 @click='change'>{{msg}}</h2>'，	
		methods：{					
			change（）{
				this.msg='222'
			}
		}
	})							

	
	局部组件：详见最上面完整示例。
	html中写法：
	接收标签：
	<app-h></app-h>					<ul> ， <ol>， <table> ， <select> 限制了能被它包裹的元素，所以这种写法在这些标签内部会不被认可。
	<p is='aaa'></p>				正常标签接收的时候，只需要设置is属性等于标签名就行了。p标签会被替换掉。	解决上面的问题。
	<components :is='a' class='t1'></components>	动态组件：这儿接收跟组件的data中的a，如果a=aaa 则渲染成<aaa></aaa> 。它设置的其他属性不会消失。比如class
	<div >
	模板写法：
	<template id='aa'>			aaa的模板 id写在这个标签上。
		<div >				这儿必须用div作为跟元素
			<bbb></bbb>		
		</div>
	</template>	
	内联模板：<aaa inline-template  v-for='a in msg' ><div>我是子组件{{a}}</div></aaa> ；components中写aaa:{}。内联写在父组件模板中，会直接渲染内部内容，作用域是子级，传数据写法相同。	
	script模板：<script type="text/x-template" id="hello-world-template">

	上级数据给下级：props ：动态传递。
		props=['msg1','msg2']
   		propF: {validator: function (value) {return value > 10}}：自定义验证函数，
		required: true，必须传数据。
		上级组件可以在模板中直接调用下级组件的名字，用于显示下级组件的模板。
		在上级模板中下级模板的名字绑定一个自定义属性:m='msg'，并且在子组件中写上props：['m']，则此处的m为上级msg的信息；{{m}}
		子组件不能直接更改父组件的msg,this.msg='aaa'会报错，但可以先让它等于自己的数据，再在mounted函数中调用自己的数据。这样不影响父组件数据。
		如果直接传对象给子组件，可以修改对象的属性，父组件也会被修改。
	
	下级传数据给上级：
		在父组件的模板中，调用子组件。子组件的标签属性用@msgevent='get',其中mesevent是子组件创建的伪事件：this.$emit('msgevent','datax')，这儿写在方法中；
		
	模板相关属性	模板显示标签：指<aaa></aaa>,这儿不指template。
		slot：	子组件模板中，站位标签,放在模板标签中，按照name值为模板显示标签中的标签站位。
		<aaa>							//模板显示标签中的属性，只会接收props['b']穿件或$emit('evt','msg')发射过得的:b、@evt。其他会出错
			<div slot='slot1'>slot1</div>			//此处添加事件是上级组件的事件，并不是aaa的。
			<div slot='slot2'>slot2</div>
		</aaa>

		<template id="aaa"> 				
			<div >
				<slot name='slot2'>这是默认情况，如果组件标签中有数据，此段话会被替换掉</slot>
				<p>p标签</p>
				<slot name='slot1'>这是默认情况，如果组件标签中有数据，此段话会被替换掉</slot>
			</div>
		</template>
		slot:作用域卡槽：子组件标签放在父组件模板中，但是msg都只能是获取父组件的msg，父组件的模板作用域是父组件。
		     改变作用域：
				父组件模板：<bbb><template slot-scope='{dd}'>{{dd}}</template></bbb>
				子组件模板：<div><slot dd='我是子组件信息'></slot></div>
				子组件for循环：<ul><li><slot v-for='an in msg' name='aa' :dd='an' ></slot></li></ul>
				 :dd能给父组传值,值为循环后的{aa: aa}
				slot-scope 是获取所有属性

		keep-alive:	<keep-alive><component :is="currentView"><!-- 非活动组件将被缓存！ --></component></keep-alive>
		异步加载：	components:{aaa(c){require(['./A.vue'],c)}}//异步加载 这儿挂的aaa是个函数，必须传个参数，require格式不能变，第二个调用c函数。c函数不必定义，第二次也可以写匿名函数。
				aaa:()=>System.import('./A.vue')  方法二 这儿this必须是全局的。
			
	组件笔记：组件被重复利用时，data数据都是分开的，为不同的实例。组件作用域在于自己的模板。

rander函数：
	当使用slot替换内容或者信息时，子组件不能动态的根据父组件提供的信息，选择相应的标签包裹内容。
	$slots.default ：无名slot .后面可以添加名字，就是name属性值。站位位置的内容。
	
	
	



异步更新队列：vm.$nextTick(callback)
		data里的值改变会立即更新数据。就算数据是输出在dom里的，他们的值也会不一样。
		但是this.$el.textContent(dom)里的值不会立马改变，想要在数据更新后做一些操作，就用this.$nextTick(callback)		

		
this：
	每个组件间this是不同的。
	fn.bind(this),会将此时的调用对象换为this
	
循环：
<li v-for='(a,b) in myData' :class="{grey:index==b}"></li>	//当数据中index=li的index时候，这个li获得 .grey的css样式。
 v-for="(value, key, index) in object"				//当对对象遍历时第三个参数为index。
 v-for='(x,y) in abc(number)'					这儿也可以调用函数abc（）

if-else：v-if='true',元素显示，v-else-if必须紧跟着，不然就不写。template标签也可以下v-if和v-else。
	<div v-if="type === 'A'">
 	 A
	</div>
	<div v-else-if="type === 'B'">
 	 B
	</div>
	<div v-else-if="type === 'C'">
	  C
	</div>
	<div v-else>
	  Not A/B/C
	</div>


单页路由：
	主要是点击不同的链接，显示不同的组件。
	<router-link to='t1'></router-link>		跳转链接
	<router-view><router-view>			标签，显示出组件。
	var router=new VueRouter(a)			a={routers：[b,c]},b与c都是组件。 
	b={path:'/t1',component:{template:'#id'}}：就是路径跟组件 path是定义组件的地址。具体见路由html。
	动态路由匹配：
		路由多次跳转时，组件不会销毁，会保存重复利用，这样钩子函数不会再重复作用。只有使用watch做出响应。
		b={path:'user/:id'}：:id表示动态地址。可以用$route.params.id接收到。其中id只是变量，可以随便写，最后$route.params是个json。组成为{id:'t1'},就是定义的变量+变量匹配到的值。	
		匹配优先级 ：谁先匹配谁优先级高。
	例：								
		let t1={path:'/home',component:{template:"#home"}，children:[]};//主要记住，path、组件、children在一个obj里。component是单数，所有不必再添加组件名称。里面data也是返回obj
		let t2={path:'/news',component:{template:"#news"}};		//children中参数也是path和components。参数都是json
		let router=new VueRouter({routes:[t1,t2]});			//在其中加入 mode: 'history', 会变成history模式，但无法直接访问链接。需要后台配合。
		router-link-active：利用router-link标签作为链接 ，当点击时替换标签a标签class会变成router-link-active
	
		编程式导航：利用在conponent或者跟标签中methods中设置方法 内容为router.push('path')。
		路由命名：给每个网页设置name属性，router-link 标签:to={name:'value',params{id:xxx}} to前面加冒号。匹配到name：'value'，的网页。名字可以当path使用。params参数只有path匹配才必要写上。
		链接命名：一般用于多个router-view标签放一堆的时候，给标签设置name属性，没有设置的是default。js组件中写法如下：
			components:{
					default:{template:'#cc'},//给模板添加名字。
					a:{template:'#bb'},
					b:{template:'#aa'},
				}
		redirect:'/one'：重定向，网页点击后路径转到/one去了。参数可以是{name:'a'} (定义网页name='a').

vuex:
	computed:
		mapState(['count'])   					this.$store.state.cont			使用：{{count}}
 		mapGetters([ 'doneTodosCount', 'anotherGetter',])	this.$store.getters
	methods:	
		mapMutations(['mutationName'])  	this.$store.commit('mutationName',n)	使用：@click='mutationName(5)',	这个5 传过去会自动变成为给函数第二个参数，第一个参数必须是state。第二个方式传参n，一般n={xx}
		mapActions([ 'actionName',])		this.$store.dispatch(actionName)	使用：@click='actionName'	this.$store.dispatch('actionA').then(() => {}) 传参上同。
	分割模块
		const moduleA = {state:{}, mutations:{},actions:{}, getters:{}}   
	挂载模块
		const store = new Vuex.Store({modules: {a: moduleA,b: moduleB}})	store.state.a ->moduleA的状态
		store.registerModule('myModule', {}) 					store.state.myModule的状态。
	store写法：
		import Vue from 'vue'
		import Vuex from 'vuex'
		Vue.use(Vuex)
		export default new Vuex.Store({
    			state: {
        			a: 1
    			},
    			actions: {
       				fn({ commit, state }, n) {			//这儿第一个一定为commit，解构写法，第二个为state，n为传过来的参数。
           			state.a += n
           			commit('add')					//fn运行完了，commit mutation的方法。
       				}
    			},
			mutations: {add() {}},
			getters:{strLength: state => state.aString.length}	第一个参数默认为state。
		})

混合：
	var vm = new Vue({mixins: [mixin],}）

myChart.showLoading()
myChart.hideLoading()

生命周期：
	beforeCreate		实例刚刚被创建。属性都没有data那些都是空的。
	created：fn		实例创建完成，属性已经有了，但dom还没有。
	beforeMount：fn		模板编译之前。
	mounted：fn		模板编译完成，花括号内的数据可以用了（显示到标签端）。
	beforeUpdate		组件更新之前。数据更新也是。
	Updated			组件更新之后。
	beforeDestroy		组件销毁之前。
	destroyed		组件销毁之后。销毁后vm不能再用。 

自定义全局插件
	
	js文件：
		export default{
			install(v){
				v.component('name',aa)//aa为{template:""}或者引入的组件文件。name为全局组件的名字。使用时按照name来使用
			}
		
		}
	main.js
		Vue.use('xx')
注意：
	数组变化监察：
		this.a.splice('0','1','zzz')     第0位开始，取一位，替换为zzz。this.a[0]='zzz'，无法探测到。不管什么情况，splice作用于数组，每次都会触发。
		example1.items.splice(newLength) vm.items.length = newLength无法探测到长度变化，在变化后加上这句代码就能够探测到了。
	
    数据绑定机制	Object.defineProperty（） // Observer：观察者
	var a= {}
	Object.defineProperty(a,"b",{
 	  set:function(newValue){
    		console.log("你要赋值给我,我的新值是"＋newValue)
   	  },
  	  get:function(){
  		 console.log("你取我的值")
   	   return 2 //注意这里，我硬编码返回2
   	  }
	})
	第三个参数属性：
	value:属性的值(不用多说了)
	writable:如果为false，属性的值就不能被重写,只能为只读了
        configurable:总开关，一旦为false，就不能再设置他的（value，writable，configurable）
	enumerable:是否能在for...in循环中遍历出来或在Object.keys中列举出来。
	
	Object.create(Object.prototype,{
	    name: 'gsgs'   
	})

elementUI 表单验证：
	el-form 		:rules='rules' 	发放所有rules
				:model='msg'	获取所有表单数据
	el-form-item 		prop="age"	rules里的age属性 确定为这项的方法
				v-model='age'	获取单个数据
	rules：{age:json}			验证规则
	msg:{age:''}				

	自定义验证：
		rules：{age：[{validator:fn,trigger:'blur'，required:ture}]}
		fn(rule,value,callback)=>{
			if(value=='a')callback(new Error(不能是a))
			callback（）
		}
					
	重置：this.$refs[formName].resetFields();
	提交： submitForm(formName) {
		this.$refs[formName].validate((valid) => {
          		if (valid) {
            		alert('submit!');
          	}

virtual dom
   使用创建虚拟dom数据，保存在内存中，更改后再将数据与旧数据对比（dom diff），再将新数据做成dom，或者在原dom上修改。主要意义在于，对比dom时不需要再次操作dom拿数据。


// 懒加载 ：
component: resolve => require(['@/components/test'] 