队列： 先进先出（排队）
栈： 先进后出
执行栈：主线程的执行栈（堆对立的）
任务队列： 异步事件(事件都是异步)等待队列，当完成时通知执行栈，执行次回调。 
event loop : 主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。
/**
 * 浏览器
 */
（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。

主线程/执行栈同步任务完成→检查任务队列→若有完成进入执行栈，


setTimeout(function(){console.log(1);}, 0);
console.log(2);
上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行"任务队列"中的回调函数！！

requestAnimationFrame() // 更新dom

/**
 * node
 */

（1）V8引擎解析JavaScript脚本。

（2）解析后的代码，调用Node API。

（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。（此处是调用库形成不同的线程（非进程））

（4）V8引擎再将结果返回给用户。

process.nextTick方法可以在当前"执行栈"的尾部----下一次Event Loop（主线程读取"任务队列"）之前----触发回调函数 不推荐使用